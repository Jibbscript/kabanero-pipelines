#Kabanero! on activate substitute StackId for text 'StackId'
apiVersion: tekton.dev/v1alpha1
kind: Task
metadata:
  name: StackId-imagename-lowercase-task
spec:
  inputs:
    resources:
    - name: docker-image
      type: image
    - name: git-source
      type: git
    params:
    - name: docker-imagename
      type: string
      default: ""
    - name: docker-imagetag
      type: string
      default: ""
  outputs:
    resources:
    - name: git-source
      type: git
  steps:
  - name: insecure-registry-setup
    securityContext:
      privileged: true
    image: docker.io/aadeshpa/appsody-buildah:0.5.8-buildah1.9.0-kubectl-jq
    command: ["/bin/bash"]
    args:
      - -c
      - |
        echo "script for setting internal registry as insecure registry in registries.conf file "

        #insecure_registries_string=$(kubectl get image.config.openshift.io/cluster -o yaml --output="jsonpath={.status.internalRegistryHostname}")
        #insecure_registries_string='hyc-wassvt-team-image-registry-docker-local.artifactory.swg-devops.com abc.com pqr.com'
        insecure_registries_string=$(kubectl get image.config.openshift.io/cluster -o yaml --output="jsonpath={.spec.registrySources.insecureRegistries[*]}")
        if [[ ! -z "$insecure_registries_string" ]]; then
           echo "The internal image registry hostname found"
 
           IFS=' ' # space is set as delimiter
           read -ra ADDR <<< ''"$insecure_registries_string"'' # str is read into an array as tokens separated by IFS
           for i in ''"${ADDR[@]}"''; do # access each element of array
             if [[ ! -z ''"$INSECURE_REGISTRTY"'' ]]; then
               INSECURE_REGISTRTY=''"$INSECURE_REGISTRTY"', '"'"''"$i"''"'"''      
             else
               INSECURE_REGISTRTY=''"'"''"$i"''"'"''
             fi
           done
           echo 'INSECURE_REGISTRTY='"$INSECURE_REGISTRTY"''
           # INSECURE_REGISTRTY='hyc-wassvt-team-image-registry-docker-local.artifactory.swg-devops.com', 'abc.com', 'pqr.com'

           cat <<- EOF > insecure_registry_setup.sh

           ORIGINAL_STRING='\[registries\.insecure\]\nregistries = \[\]'
           REPLACE_STRING='\[registries\.insecure\]\nregistries = \['"$INSECURE_REGISTRTY"'\]'

           sed -i -e ':a;N;\$!ba;s|'"\$ORIGINAL_STRING"'|'"\$REPLACE_STRING"'|' /etc/containers/registries.conf

        EOF
           chmod +x insecure_registry_setup.sh

           echo "copying the script insecure_registry_setup.sh to output path"
           cp insecure_registry_setup.sh $(outputs.resources.git-source.path)
        fi
    env:
    - name: gitsource
      value: git-source
    volumeMounts:
    - mountPath: /var/lib/containers
      name: varlibcontainers
  - name: trusted-ca-certs-setup
    securityContext:
      privileged: true
    image: docker.io/aadeshpa/appsody-buildah:0.5.8-buildah1.9.0-kubectl-jq
    command: ["/bin/bash"]
    args:
      - -c
      - |
        echo "script for setting additionalTrustedCA as 'ca.rt' from the configmap configured in 'image.config.openshift.io/cluster' resource"
        additonal_trusted_CA=$(kubectl get image.config.openshift.io/cluster -o yaml --output="jsonpath={.spec.additionalTrustedCA.name}")

        echo "additonal_trusted_CA=$additonal_trusted_CA"
        if [[ ! -z "$additonal_trusted_CA" ]]; then
           echo "Additional trusted CA configmap found"
           config_map_key_count=$(kubectl get configmap artifactory-dummy-registry-cas -n openshift-config -o json | jq '.data' | jq 'keys | length')
           echo "Total number of certificates in configmap=$config_map_key_count"

           for ((i=0;i<config_map_key_count;i++));do
              echo "i=$i"
              key=$(kubectl get configmap artifactory-dummy-registry-cas -n openshift-config -o json | jq '.data' | jq 'keys['"$i"']')
              echo "key=$key"

              #sed command to remove double quotes from beginning and the end of the above key(example key="abc.pqr.com") variable value
              key=$(sed -e 's/^"//' -e 's/"$//' <<<$key)
              echo "key after the removal of double quotes=$key"
              #sed command to replace '.' with '\.' to escape it while using ahead to fetch that key's value from the map
              key=$(sed -e 's/\./\\./g' <<< "$key")
              echo "key after the replacing dots with \dot =$key"

              cert_value=$(kubectl get configmap artifactory-dummy-registry-cas -n openshift-config --output="jsonpath={.data.$key}")
              echo "cert_value=$cert_value"
           done

        fi
    env:
    - name: gitsource
      value: git-source
    volumeMounts:
    - mountPath: /var/lib/containers
      name: varlibcontainers
  - name: imagename-lowercase
    securityContext:
      privileged: true
    image: appsody/appsody-buildah:0.5.8-buildah1.9.0
    command: ["/bin/bash"]
    args:
      - -c
      - |
        #This step generates a script with the logic to change docker-image resource url with image_name as lowercase.
        # usage example 1 in usecases where input param 'docker-imagename=appsodyMPversion' and 'docker-imagetag=abcDEF' is present and 'docker-iamge' url= image-registry.openshift-image-registry.svc:5000/kabanero
        #  Then output should be url with docker-imagename 'appsodyMPversion' as lowercase, OutputURL = 'image-registry.openshift-image-registry.svc:5000/kabanero/appsodympversion:abcDEF'
        # usage example 2 in jenkins case where input param 'docker-imagename' and 'docker-imagetag' are empty ,'docker-image' url=docker.io/abcd, and if app-deploy file has 'name=java-MP-project' 
        #  Then first the url is constructed from 'app-deploy.yaml' file from the github application project. Secondly the imagename in the url is converted to lowercase.
        #  Output should be a constructed url and lowercase 'docker-imagename=java-mp-project', OutputURL = 'docker.io/abcd/java-mp-project' 

        cat <<- "EOF" > imageurl_imagename_lowercase.sh
        #Script Usage ./imageurl_imagename_lowercase.sh

        docker_registry_url=$(inputs.resources.docker-image.url)
        docker_imagename=$(inputs.params.docker-imagename)
        docker_imagetag=$(inputs.params.docker-imagetag)
        app_deploy_filename="app-deploy.yaml"

        if [[ -z "$docker_registry_url" ]]; then
           echo "Error : The input parameter docker-image resource url to the script is empty, please provide it and try again(Possible value example: docker.io/<docker-userid>, image-registry.openshift-image-registry.svc:5000/kabanero)"
           exit 1
        else
           if [[ -z "$docker_imagename"  ]]; then
              if [[ -f /workspace/$gitsource/$app_deploy_filename ]];then
                 cd /workspace/$gitsource
                 APPNAME=$(awk '/^  name:/ {print $2; exit}' $app_deploy_filename)

                 docker_imagename_lowercase=$(echo $APPNAME |  tr '[:upper:]' '[:lower:]')
              else
                 echo "Error : docker_imagename is empty and the $app_deploy_filename is not present in the github appsody project.
                 Either provide the value for the variable or make the $app_deploy_filename file available in the github appsody project
                 Case 1: If you are running a pipeline where you do not want the docker imagename to be coming from 'app-deploy.yaml' ,
                         you would need to provide the imagename from the Trigger file.
                         (Hint: Check the pipeline trigger file passing the input parameter 'docker_imagename' to the pipelines)
                 Case 2: If your requirement is to pull the imagename from the  'app-deploy.yaml' file variable 'name' , 
                         then you need to make sure that you have the file available in the appsody project in github whose url you have provided as git-source to the pipeline"
                 exit 1                 
              fi
           else
              docker_imagename_lowercase=$(echo $docker_imagename |  tr '[:upper:]' '[:lower:]')
           fi
        fi

          #If it reaches here it means it has set the variable docker_imagename_lowercase correctly.
        if [[ ! -z "$docker_imagetag" ]]; then
            DOCKER_IMAGE_URL=$docker_registry_url/$docker_imagename_lowercase:$docker_imagetag
        else
            DOCKER_IMAGE_URL=$docker_registry_url/$docker_imagename_lowercase
        fi
        echo "$DOCKER_IMAGE_URL"
          
        EOF
        chmod 755 imageurl_imagename_lowercase.sh

        echo "imageurl_imagename_lowercase.sh content you built..."
        cat imageurl_imagename_lowercase.sh
        
        #Copy of all the content of git-source from input resources to output resources, so it could be passed to next task.
        cp -r $(inputs.resources.git-source.path)/. $(outputs.resources.git-source.path)
        #Copy the script 'imageurl_imagename_lowercase.sh' generated here to output git-source resource.
        cp imageurl_imagename_lowercase.sh $(outputs.resources.git-source.path)
    env:
    - name: gitsource
      value: git-source
    volumeMounts:
    - mountPath: /var/lib/containers
      name: varlibcontainers
  volumes:
  - name: varlibcontainers
    emptyDir: {}